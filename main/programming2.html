<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title>Programming 2</title>
</head>
<body lang="en-US" dir="ltr">
<table width="100%" cellpadding="4" cellspacing="0" style="page-break-before: always; page-break-inside: avoid">
	<col width="128*">
	<col width="128*">
	<tr valign="top">
		<td width="50%" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px solid #808080; border-right: none; padding-top: 0.04in; padding-bottom: 0.04in; padding-left: 0.04in; padding-right: 0in">
			<p><a href="main.html">Home</a> &gt; Programming Prerequisites</p>
		</td>
		<td width="50%" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px solid #808080; border-right: 1px solid #808080; padding: 0.04in">
			<p align="right">&lt; <a href="programming.html">prev</a> | next &gt;
						</p>
		</td>
	</tr>
</table>
<h1 style="page-break-before: always">Programming part 2:</h1>
<p><b>For-loops</b></p>
<p>Lists have a lot of uses, we won't try to discuss hardly a fraction
of them (the purpose of this sentences is motivation for caring about lists, beyond what we do with them in past and future contexts). But one important application is their use in another large and
important subject: for-loops. For-loops are used to do &quot;something&quot;
over and over. We can use this to illustrate repeated addition,
again, but this time more efficiently--letting the computer do the
repetitions rather than us having to issue the command over and over.
Before getting to that, let's see a simpler example.</p>
<p>In[n]: r = [0, 1, 2, 3]</p>
<p>In[n+1]: for element in r:</p>
<p>...&nbsp;&nbsp;&nbsp;&nbsp;print(element)</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>Rather than explain this syntax, just contrast a few examples.

<p class="code">for i in ['a', 'b', 'c']:</p>
<p class>...&nbsp;&nbsp;&nbsp;&nbsp;print(i)</p>

Notice how we always need "for" followed by a variable, followed by "in", followed by a list, followed by a colon--<i>but that's not all!</i>  We also need to follow <i>that</i> by a linebreak, <i>followed by four spaces</i>.
We describe this syntax with the notation <font class="code">for &lt;var&gt; in &lt;list&gt;:</font>
When you
line-break the console automatically puts in <font class="code">... </font> , an ellipsis with
indentation. The ellipsis is just "part of the console", not the code.  It's just there to show you a prompt after which you insert text.  <br><br>
But the spaces after the elipsis are part of the code and are required for
the for-loop to work. To make the point clearer, let's start talking
about the editor, the left half of the Spyder window. If you click on
it and type code, you are just typing in a text editor, like Word or Notepad, although it comes with
extra features--but fundamentally it's just an editor to type code.
Try entering the following into the editor.</p>
<p>1| r = [0, 1, 2, 3]</p>
<p>2| for i in r:</p>
<p>3|&nbsp;&nbsp;&nbsp;&nbsp;print(i)</p>
<p>Notice that the third line begins with four spaces for
indentation. This is necessary for the program to work correctly. If
you're using a smart text editor (like in Spyder) it may turn your
&lt;tab&gt; command into four spaces automatically, but if your editor is not
smart then you'll need to do this manually. <br><br>

Spaces are not always
important, for instance, you could enter into the console

<p class="code">In[n]: 1+&nbsp;&nbsp;&nbsp;&nbsp;2</p>
<p class="code">Out[n]: 3</p>

But spaces for indentation, like in for-loops and certain other &quot;control
structures&quot;, are important.</p>
<p>Of course in the editor, pressing enter doesn't cause Python to
run, it just causes a line-break. To get your code to run from the editor, you have to go to the toolbar, or menu, or
whatever--if you can't figure it out by playing around, you can
google. On many systems, simply typing F5 will cause the script to run.  <br><br>
When you do eventually run the code from the editor in Spyder, the first time you do this you'll
get a pop-up window. Just click &quot;Ok&quot; or whatever to get
passed the window. When it runs the code above, you should see the console print out
0 through 3. Code that you enter in the editor and run, will often print in
the console. However, if you run code from the editor, sometimes
you'll see fewer print-outs. For instance, if you put 1+1 on a line
in the editor and run it, nothing will show. If you want things to
show, you have to put an explicit ^^print()`` command like in the code
above.
</p>
<p>We (I) have drifted in our conversation away from for-loops, which are ostensibly the topic of this subsection.  Let's return.  Just to say it outright, the way the for-loop works is that the
variable, like ^^i`` in the code above, sequentially takes each value in
the list ^^r`` and does something, in this case prints. Here's the
multiplication example, where we see an illustration of 3*4. To show
the result we want to add 3 with itself 4 times. To do that we need
to make a variable that will store our progress as we march through
the list. I'll use ^^ag`` for the this variable, to indicate that it's
an &quot;aggregator&quot;. We need to initialize the aggregator to 0 so that we,
in a sense, &quot;start at the start&quot;. Run the following code
and you should see 12 printed in the console.
</p>
<p class="code">1| r = [3, 3, 3, 3]</p>
<p class="code">2| ag = 0</p>
<p class="code">3| for num in r:</p>
<p class="code">4|&nbsp;&nbsp;&nbsp;&nbsp;ag += num</p>
<p>Nothing prints when you run it, though. Why?</p>
<p>What this does is first set ^^ag`` to 0, then ^^num`` takes the value 3
(the first 3 in ^^r``) and this is summed to ^^ag`` making it now store 6.
Then ^^num`` takes the next value, which just happens to be 3 again, and
sums it to ^^ag`` making it 9, and one more time and ^^ag`` stores 12. At
this point Python has reached the end of the script and therefore
terminates the loop. But we haven't told Python to print anything! We have to do that explicitly when working in the editor. If we
change it to the following, it will print 12 to the console.</p>
<p class="code">1| r = [3, 3, 3, 3]</p>
<p class="code">2| ag = 0</p>
<p class="code">3| for num in r:</p>
<p class="code">4| &nbsp;&nbsp;&nbsp;ag += num</p>
<p class="code">5| print(ag)</p>
<p>Notice that un-indenting ^^ag`` is important to make sure that the
print line occurs only after the for-loop has terminated. Try
indenting the 5<sup>th</sup> line to see what happens when it's
included inside the for-loop.</p>
<p>One important function in Python is the ^^range()`` function. In
effect ^^range(5)`` automatically produces a list of the numbers 0
through 4. That's not exactly true, but it's close enough to true. If you run
</p>
<p class="code">1| for num in range(5):</p>
<p class="code">2| &nbsp;&nbsp;&nbsp;print(num)</p>
<p>you will get a print-out of the numbers 0 through 4. Here's an
exercise: find a way to use this to compute 20!, which is pronounced
&quot;twenty factorial&quot;. This is the number you get by computing
1*2*3*4*...*19*20. The solution is on the next line.</p>
<p class="code">1| ag = 1</p>
<p class="code">2| for i in range(20):</p>
<p class="code">3| &nbsp;&nbsp;&nbsp;ag *= i+1</p>
<p class="code">4| print(ag)</p>

<hr/>

<p><b>If-then</b></p>
<p>There are many uses of the if-then control structure. For one
thing we can loop over a list and operate only on certain elements.
Suppose we have a list and only want to print the elements larger
than 5. Then we can write</p>
<p class="code">1| exampleList = [10, 2, 7, 3, 5, 12]</p>
<p class="code">2| for element in exampleList:</p>
<p class="code">3| if element &gt; 5:</p>
<p class="code">4| print(element)</p>
<p>We can also write code that effectively computes the absolute
value of a number:</p>
<p class="code">1| x = 10</p>
<p class="code">2| if x &gt; 0:</p>
<p class="code">3| print(x)</p>
<p class="code">4| if not x &gt; 0:</p>
<p class="code">5| print(-1*x)</p>
<p>It is common to abbreviate this with the if-else syntax which I
demonstrate below.</p>
<p class="code">1| x = 10</p>
<p class="code">2| if x &gt; 0:</p>
<p class="code">3| print(x)</p>
<p class="code">4| else:</p>
<p class="code">5| print(-1*x)</p>
<p>This code produces the same result as the previous code. In either
case you can change the value of x and see the print result change
each time that you run the code. In particular you'll want to make x
negative to see that the print result stays positive.</p>
<p>Just as we can formally describe the syntax of the for-loop with
for &lt;var&gt; in &lt;list&gt;: we can also describe if &lt;bool&gt;:.
By this I mean that, whatever comes after if must be a &quot;boolean&quot;,
which might seem strange: We don't see a boolean in if x &gt; 0:. Yet
it is actually there.
</p>
<p>Try print(2 &gt; 0) and print(not 2 &gt; 0) either in the console
or by writing a script in the editor. You'll see the console print
boolean values. Thus in the code if x &gt; 0: the part x &gt; 0 will
evaluate to a boolean (so long as x stores a number). In an
if-declaration you must always have an expression that evaluates to a
boolean.</p>
<p>Here's another example.</p>
<p>1| if 'abcdefgh'[2] == 'a':</p>
<p>2| print('a')</p>
<p>3| else:</p>
<p>4| print('not a')</p>
<p>The == syntax is used to <i>test</i><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">for
equality. It returns a boolean of True if the objects are equal,
hence 1 == 1 would return True and 1 == 2 would return False. Notice
how this is different from the = syntax, which is used to store
information in a variable. Thus 1 = 2 would return an error because 1
is not a variable. Getting back to this code, you can now understand
what 'abcdefgh[2] does, it just selects the &quot;second&quot;
element (counting from 0) which is 'c'. This could have just been
written as 'c' rather than 'abcdefgh[2] but I wanted to make it an
exercise to read what it's saying. From here you can understand what
'abcdefgh[2] == 'a' is saying; it's testing whether these are equal.
They aren't equal so it returns the boolean False. The if-declaration
therefore reads a False value and does not execute the code on line
2. But because line 1 read a False value, therefore we do run the
code in the else-block, i.e. line 4 of the code will execute. </span></span>
</p>
<p>As usual, the syntax is somewhat rigid: To write an if-declaration
you must first write if followed by an expression that evaluates to a
boolean, followed by a colon; on the next line you must indent by
four spaces.</p>
<hr/>

<p><b>Types and coercion</b></p>
<p>We will often want to combine text and numbers in order to have a
nice print-out of some of our numerical results. As we've see,
though, this isn't possible in a direct way. print('Here is a number:
' + 1) doesn't produce text, it just causes an error. That's because
we're trying to combine a text and number object which is confusing
to Python. Instead we need to convert, or what is sometimes called
&quot;coerce&quot;, the number into a string so that they can be
concatenated.
</p>
<p>In[n]: 'Here is a number:' + str(1)</p>
<p>Out[n]: 'Here is a number: 1'</p>
<p>This will be useful when we need to initially do calculations with
number objects, and then at the end of the day, report certain parts
of the results in a string.</p>
<p>We might as well comment now on type coercion. You can convert
many different objects to an integer using the int() function and
Python makes reasonable guesses about what you mean at least some of
the time. Notice that int() does not perform rounding--for that you
need the round() function. Instead int() performs what's called the
&quot;floor&quot; function. Don't worry about it if this is at all
confusing, the point here is just to convey the gist of how you
convert a certain type of object into an integer type.</p>
<p>In[n]: int(2.5)</p>
<p>Out[n]: 2</p>
<p>In[n+1]: int(1)</p>
<p>Out[n+1]: 1</p>
<p>In[n+2]: int(True)</p>
<p>Out[n+2]: 1</p>
<p>If you try to enter int('a') however, Python throws an error
because it has no guess about what you want for this. The boolean
result that int(True) evaluates to 1 may be surprising but it's not
terribly surprising that true is &quot;kinda like 1&quot; and false
is &quot;kinda like 0&quot;. In fact when we study boolean algebras
later on, we will take this idea even more seriously. But even for
now it kinda makes sense: 0 is the probability we give to
certainly-false things and 1 is the probability we give to
certainly-true things. Anyway these are just cute and motivating
considerations. Back to programming.</p>
<p>You can also convert just about anything to a string using str().</p>
<p>In[n+3]: str(2.5)</p>
<p>Out[n+3]: '2.5'</p>
<p>In[n+4]: str(True)</p>
<p>Out[n+4]: &quot;True&quot;</p>
<p>In[n+5]: str([1,2,3])</p>
<p>Out[n+5]: '[1, 2, 3]'</p>
<p>And you can convert integers and booleans to floats, but not
strings or lists. In fact, I once said that range(5) is not a list
but it's very list-like and therefore can be used in many places
where a list can be used. But one way to see how it differs from a
list is to see how it prints.</p>
<p>In[n+6]: range(5)</p>
<p>Out[n+6]: range(0,5)</p>
<p>In[n+7]: [0, 1, 2, 3, 4]</p>
<p>Out[n+7]: [0, 1, 2, 3, 4]</p>
<p>So range(5) prints differently from [0, 1, 2, 3, 4] and indicates
that there's some subtle difference between them. In fact range(5) is
what's called an &quot;iterator&quot; and I won't go into what that
means right now, it's too complicated and not important enough for us
to justify getting into it right now. But we can convert the iterator
into a list, and then see everything inside of it the way we can with
lists.</p>
<p>In[n+8]: list(range(5))</p>
<p>Out[n+8]: [0, 1, 2, 3, 4]</p>
<hr/>

<p><b>Modules</b></p>
<p>The last thing to discuss is how to use objects and modules. One
module that I'll use frequently is SymPy. To get access to it just
include import sympy as sp at the top of the script. Here's an
example wherein I compute 20! using its built-in function.</p>
<p>1| import sympy as sp</p>
<p>2| print(sp.factorial(20))</p>
<p>What's going on here is that sympy was installed automatically
when you installed Anaconda. By importing it, you gain access to its
functions. There are a lot of good reasons why you have to import it
in order to gain access to it but for now, we won't discuss them.
</p>
<p>Once it's imported, it's like a toolbox, it comes with a bunch of
different functions, but to use them you have to use the &quot;dot&quot;
notation. Hence writing sp. and then following the . with the name of
a function you want to use, is the standard syntax. Just for another
demonstration you can use SymPy to compute the cosine (whatever that
means) of a value.</p>
<p>1| import sympy as sp</p>
<p>2| print(sp.cos(1))</p>
<p>We'll often want to represent functions of a real variable,
though, and to do that you need to tell SymPy to reserve certain
variables to be used in mathematical expressions. So for instance if
I want to define the function x**2 (which is &quot;x squared&quot; or
x<sup>2</sup>), and then plot it, one would have to write
</p>
<p>1| import sympy as sp</p>
<p>2| x = sp.variables('x')</p>
<p>3| f = x**2</p>
<p>4| sp.plot(f)</p>
<p>Hopefully in the console a nice plot of the function showed up.
</p>
<p>For now we end Python primer, as this is about as much as is
necessary to get warmed up, playing around with it, and pick up extra
skills as needed in the lessons.</p>
<p><br/>
<br/>

</p>
</body>
</html>
